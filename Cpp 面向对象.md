## Cpp 面向对象



### 拷贝控制

目录

- 拷贝构造函数
- 拷贝赋值运算符
- 交换操作
- 

#### 拷贝构造函数

> 拷贝构造函数：如果一个构造函数的第一个参数是自身类类型的引用，且其他参数都有默认值。

- 这个引用几乎都是const的，虽然可以不是。
- 拷贝构造函数在几种情况下都会被隐式地使用。因此，拷贝构造函数通常不应该是explicit的
- 没有定义拷贝构造函数的时候，编译器会合成一个（合成版本的会依次逐个拷贝非static成员,数组成员会逐个拷贝数组中的元素）

```cpp
class Foo {
public:
    Foo(){}
    //拷贝构造函数
    Foo(const Foo &foo,int a = 10){}
};

```



- 拷贝初始化有时候也会使用移动构造函数而非拷贝构造函数

##### 拷贝初始化时机

- 使用 = 定义对象
- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中

#### 拷贝赋值运算符

> 主要控制类对象的赋值过程

- 赋值运算符通常应该返回一个指向其左侧运算对象的引用
- 标准款通常要求保存在容器中的类型要具有赋值运算符，且返回值是左侧运算对象的引用

> 合成的拷贝赋值运算符：它会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。

```cpp
class Foo {
public:
    Foo() {}

    //拷贝构造函数
    Foo(const Foo &foo) {
        std::cout << "Foo copy constr" << std::endl;
    }

    //拷贝赋值运算符
    Foo& operator=(const Foo& foo);
};
```

##### 编写的时候需要注意

- 如果将一个对象赋予它自身，赋值运算符必须能正确工作。
- 大多数赋值运算符组合了析构函数和拷贝构造函数的工作











##### 对某些类来说，编译器将这些合成的函数（拷贝，赋值，析构）定义为删除的函数

- 如果类的某个成员的析构函数是删除的或不可访问的（例如，是private的），则类的合成析构函数被定义为删除的。
- 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。
- 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。
-  如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器（参见2.6.1节，第65页），或是类有一个const成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。

本质上，这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的

#### 三五法则

- 需要析构函数的类也需要拷贝和赋值操作
- 需要拷贝操作的类也需要赋值操作，反之亦然





#### 交换操作

> 对于那些与重排元素顺序的算法一起使用的类，定义swap是非常重要的,这类算法在需要交换两个元素时会调用swap.

```cpp
class Foo {
public:
    Foo() {}

    //拷贝构造函数
    Foo(const Foo &foo) {
        std::cout << "Foo copy constr" << std::endl;
    }

    //拷贝赋值运算符
    Foo& operator=(const Foo& foo);

    //swap
    friend void swap(Foo &,Foo &);
private:
    std::string *ps;
};

inline void swap(Foo &lhs, Foo &rhs) {
    //交换指针，而不是交换string数据
    using std::swap;
    swap(lhs.ps,rhs.ps);
}
```

与拷贝控制成员不同，swap并不是必要的。但是，对于分配了资源的类，定义swap可能是一种很重要的优化手段。

> swap函数应该调用swap，而不是std：：swap



##### 在赋值运算符中使用swap

> 定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为拷贝并交换（copy and swap）的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换

```cpp
//注意这里foo是按值传递的，意味着会调用拷贝构造函数，这里的foo将会是一个副本
Foo &Foo::operator=(Foo foo) {
    swap(*this,foo);// 将左侧对象和副本foo交换
    return *this;//返回之后副本被销毁
}
```

使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。